---
title: "Collostruction Analysis"
author: "Alvin Cheng-Hsien Chen"
date: "October 7, 2025"
output:
  prettydoc::html_pretty:
    theme: leonids
    highlight: github    
    toc: true
    number_sections: true
    df_print: paged
    css: style.css
---

```{r include=F, purl=F}
## Rmarkdown settings
knitr::opts_chunk$set(message = F, warning = F)
knitr::opts_chunk$set(fig.width=8, fig.height=6, dpi=300, fig.retina=2, cols.print = 5)

## Automatically use showtext to render plots
## If loading showtext throws errors, install: https://www.xquartz.org/
library(showtext)
showtext_auto(enable = TRUE)
```


## Loading packages

```{r}
library(tidyverse)
library(tidytext)
library(quanteda)
library(stringr)
library(jiebaR)
library(readtext)
```

## Objectives

In this tutorial, I would like to talk about the relationship between a construction and words. Words may co-occur to form **collocation** patterns. When words co-occur with a particular morphosyntactic pattern, they would form **collostruction** patterns.

Here I would like to introduce a widely-applied method for research on the meanings of constructional schemas---**Collostructional Aanalysis** [@stefanowitsch2003]. This is the major framework in corpus linguistics for the study of the relationship between words and constructions.

The idea behind collostructional analysis is simple: the meaning of a morphosyntactic construction can be determined very often by its co-occurring words.

In particular, words that are strongly associated (i.e., co-occurring) with the construction are referred to as **collexemes** of the construction.

**Collostructional Analysis** is an umbrella term, which covers several sub-analyses for constructional semantics:

-   **collexeme** analysis (cf. @stefanowitsch2003)
-   **co-varying collexeme** analysis (cf. @stefanowitsch2005)
-   **distinctive collexeme** analysis (cf. @gries2004)

This tutorial will first focus on **collexeme analysis**, whose principles can be extended to the other analyses.

Also, I will demonstrate how we can conduct a collexeme analysis by using the R script written by Stefan Gries ([Collostructional Analysis](http://www.stgries.info/teaching/groningen/index.html)).

## Corpus

In this tutorial, I will use the Apple News Corpus as a toy corpus. (It is available in: `demo_data/applenews10000.tar.gz`.)

And in this demonstration, I would like to look at a particular morphosyntactic frame in Chinese, `X + 起來`. Our goal is simple: in order to find out the semantics of this constructional schema, it would be very informative if we can find out which words tend to strongly occupy this `X` slot of the constructional schema.

That is, we are interested in the collexemes of the construction `X + 起來` and their degree of semantic coherence.

So our first step is to load the text collections of Apple News into R and create a `corpus` object.

```{r purl=T}
## Load Data
apple_df <-
  readtext("demo_data/applenews10000.tar.gz", encoding = "UTF-8") %>% ## loading data
  filter(!str_detect(text, "^\\s*$")) %>% ## removing empty docs
  mutate(doc_id = row_number()) ## create index
```

::: try
Raw texts usually include a lot of noise. For example, texts may include invisible **control characters**, **redundant white-spaces**, and **duplicate line breaks**. These redundant characters may have an impact on the word segmentation performance. It is often suggested to clean up the raw texts before tokenization.

In the above example, I created a simple function, `normalize_text()`. You can always create a more sophisticated one that is designed for your own corpus data.
:::

- Define how we would like to preprocess the data:

```{r}
## Text normalization function
## Define a function
normalize_document <- function(texts) {
  texts %>%
    str_replace_all("\\p{C}", " ") %>%  ## remove control chars
    str_replace_all("[\\s|\\n]+", " ") %>%  ## replace whitespaces/linebreaks with one whitespace
    trimws
}
```

- An example:

```{r}
## Example usage of `normalize_document()`
## before cleaning
apple_df$text[1]
## after cleaning
normalize_document(apple_df$text[1])
```

- Preprocess all texts in the corpus

```{r}
## Apply cleaning to all docs
apple_df$text <- normalize_document(apple_df$text)
```


## Word Segmentation

We use the self-defined word tokenization method based on `jiebar`. There are three important steps:

1.  We first initialize a `jiebar` language model using `worker()`;
2.  We then define a function `word_seg_text()`, which enriches the raw texts with word boundaries and parts-of-speech tags;
3.  Then we apply the function `word_seg_text()` to the original texts and create a new column to our text-based data frame, a column with the enriched versions of the original texts.

This new column will serve as the basis for later construction extraction.

```{r purl=T}
# Initialize jiebar
segmenter <- worker(user = "demo_data/dict-ch-user.txt",
                    bylines = F, ## ignore lines
                    symbol = F)  ## ignore symbols

# Define function
word_seg_text <- function(text, jiebar) {
  segment(as.character(text), jiebar) %>% # word tokenize
    str_c(collapse = " ") ## concatenate word tokens into long strings
}
```

::: info
Our self-defined function `word_seg_text()` is a simple function to convert a Chinese raw text into am enriched version with word boundaries and POS tags.

```{r}
word_seg_text(apple_df$text[1], segmenter)
```
:::

::: alert
Please note that in this example, we did not include the parts-of-speech tagging in order to keep this example as simple as possible. However, in real studies, we often need to rely on the POS tags if we want to improve the quality of the pattern retrieval.

Therefore, for your own project, probably you need to revise the `word_seg_text()` and also the `jiebar` language model (`worker()`) if you would like to include the POS tag annotation in the data processing.
:::

- We perform word segmentation to all texts in the corpus

```{r}
# Apply the function
apple_df <- apple_df %>%
  mutate(text_tag = map_chr(text, ~ word_seg_text(.x, segmenter)))
```


```{r echo=F, purl=F}
apple_df %>%
  head(100) %>%
  mutate(text = str_sub(text, 0,100) %>% sprintf("%s...",.),
         text_tag = str_sub(text_tag, 0,100) %>% sprintf("%s...",.))
```


## Extract Constructions

::: info

Both [regular expressions](https://en.wikipedia.org/wiki/Regular_expression) and [corpus query languages](https://www.sketchengine.eu/documentation/corpus-querying/) share the idea of pattern matching. They let you describe a search pattern in a formal way and then scan through text to find all the places where that pattern occurs. In both cases, you write rules instead of manually searching, which makes them powerful for handling large amounts of data.

The key difference is that regex patterns work only on surface strings, while corpus query languages extend this logic to structured linguistic information.

:::

With the word boundary information, we can now extract our target patterns from the corpus using regular expressions with `unnest_tokens()`.

- Define the constructional pattern:

```{r purl=T}
# Define regex
pattern_qilai <- "[^\\s]+\\s起來\\b"
#pattern_qilai <- "\\b((?:\\S+\\s){0,5})(\\S+\\s起來)\\b((?:\\s\\S+){0,5})"
```

- Extract the patterns from the corpus

```{r}
# Extract patterns

apple_qilai <- apple_df %>%
  select(-text) %>% ## dont need original texts
  unnest_tokens(
    output = construction, ## name for new unit
    input = text_tag, ## name of old unit
    token = function(x) ## unnesting function
      str_extract_all(x, pattern = pattern_qilai)
  )

```

- Check the results

```{r}
# Print
apple_qilai
```

## Exploratory/Descriptive Analysis

Usually before the statistical/quantitative analysis, we examine our data in an exploratory way.

```{r}
apple_qilai %>%
  group_by(construction) %>%
  summarize(freq = n(),
            docfreq = n_distinct(doc_id)) -> apple_qilai_dist

apple_qilai_dist %>% 
  arrange(-freq) %>%
  top_n(50, freq)
```

## Distributional Information Needed for Collostruction Analysis

To perform the **collexeme analysis**, which is essentially a statistical analysis of the association between words and a specific construction, we need to collect necessary distributional information of the words (`X`) and the construction (`X + 起來`).

In particular, to use Stefan Gries' R script of Collostructional Analysis, we need the following information:

1.  Joint Frequencies of the words and the construction (e.g., frequency count of `吃＋起來`)
2.  Frequencies of Words in Corpus (e.g., frequency count of `吃`)
3.  Corpus Size (e.g., total number of words in corpus)

::: info
Take the word `使用` for example. We need the following distributional information:

1.  Joint Frequencies: the frequency of `使用＋起來`
2.  The frequency of `使用` in Corpus
3.  Corpus Size (total number of words in corpus)
:::

### Word Frequency List

Let's attend to the second distributional information needed for the analysis : the frequencies of words.

It is easy to get the word frequencies of the entire corpus.

With the tokenized texts, we first convert the **text-based** data frame into a **word-based** one; then we create the word frequency list via simple data manipulation tricks.

```{r purl=T}
## create word freq list
apple_word_freq <- apple_df %>%
  select(-text) %>% ## dont need original raw texts
  unnest_tokens( ## tokenization
    word,  ## new unit
    text_tag,  ## old unit
    token = function(x)  ## tokenization function
      str_split(x, "\\s+")
  ) %>%
  filter(nzchar(word)) %>% ## remove empty strings
  count(word, sort = T)

apple_word_freq %>%
  head(100)
```

::: alert
In the above example, when we convert our data frame from a text-based to a word-based one, we didn't use any specific tokenization function in `unnest_tokens()` because we have already obtained the **enriched version** of the texts, i.e., texts where each word token is delimited by a white-space. Therefore, the `unnest_tokens()` here is a lot simpler: we simply tokenize the texts into word tokens based on the **known delimiter**, i.e., the white-spaces.
:::

### Joint Frequencies

Now let's attend to the first distributional information needed for the analysis: the joint frequencies of `X+起來` construction.

With all the **pattern-based** data frame, `apple_qilai`, this should be simple. Also, because we have created the word frequency list of the corpus, we can include the frequency of the collexeme in our table as well.

```{r purl=T}
## Joint frequency table
apple_qilai_freq <- apple_qilai %>%
  count(construction, sort = T) %>%  ## get joint frequencies
  tidyr::separate(col = "construction", ## restructure data frame
                  into = c("word", "construction"),
                  sep = "\\s") %>%
  ## identify the freq of X in X_起來
  mutate(word_freq = apple_word_freq$n[match(word, apple_word_freq$word)])

apple_qilai_freq
```

### Input for `coll.analysis.r`

Now we have almost all distributional information needed for the Collostructional Analysis.

Let's see how we can use Stefan Gries' script, `coll.analysis.r`, to perform the collostructional analysis on our data set.

The script `coll.analysis.r` expects a particular input format.

The input file should be a `tsv` file, which includes a three-column table:

1.  Word
2.  Word frequency in the corpus
3.  Word joint frequency with the construction

```{r purl=T}
## prepare a tsv
## for coll analysis
apple_qilai_freq %>%
  select(word, word_freq, n) %>%
  write_tsv("qilai.tsv")
```

::: alert
In the later Stefan Gries' R script, it requires that the input be a tab-delimited file (`tsv`), not a comma-delimited file (`csv`).
:::

### Corpus Size

In addition to the input file, Stefan Gries' `coll.analysis.r` also requires a few general statistics for the computing of association measures.

We prepare necessary distributional information for the later collostructional analysis:

1.  Corpus size: The total number of words in the corpus
2.  Construction size: the total number of the construction tokens in the corpus

Later when we run Gries' script, we need to enter these numbers manually in the terminal.

```{r purl=T}
## corpus information
cat("Corpus Size: ", sum(apple_word_freq$n), "\n")
cat("Construction Size: ", sum(apple_qilai_freq$n), "\n")
```

------------------------------------------------------------------------

::: try
Sometimes you may need to keep important information printed in the R console in an external file for later use. There's a very useful function, `sink()`, which allows you to easily keep track of the outputs printed in the R console and save these outputs in an external text file.

```{r purl=T, results=F, collapse=T}
## save info in a text
sink("qilai_info.txt") ## start flushing outputs to the file not the terminal
cat("Corpus Size: ", sum(apple_word_freq$n), "\n")
cat("Construction Size: ", sum(apple_qilai_freq$n), "\n")
sink() ## end flushing
```

You should be able to find a newly created file, `qilai_info.txt`, in your working directory, where you can keep track of the progress reports of your requested information.

Therefore, `sink()` is a useful function that helps you direct necessray terminal outputs to an external file for later use.
:::


## Running Collostructional Analysis

::: warning
Stefan Gries' `coll.analysis.r` will initialize the analysis by first **removing all the objects** in your current R session. Please make sure that you have saved all necerssary information/objects in your current R session before you source the script.
:::

Finally we are ready to perform the collostructional analysis using Stefan Gries' [`coll.analysis.r`](https://www.stgries.info/teaching/groningen/index.html).

We can use `source()` to run the entire R script. The `coll.analysis.r` is available on Stefan Gries' website. We can either save the script onto our laptop and run it offline or source the online version ( [`coll.analysis.r`](https://www.stgries.info/teaching/groningen/index.html) directly.

```{r eval=F, echo=T, purl=T}
######################################
##      Preloading Gries' Functions ##
######################################
source("https://www.stgries.info/teaching/groningen/coll.analysis.r")


## Run the interactive analysis
coll.analysis()
```

------------------------------------------------------------------------

`coll.analysis.r` is an R script with interactive instructions.

When you run the analysis in R (the function `coll.analysis()`), you will be prompted with guided questions, to which you would need to fill in necessary information/answers in the R terminal.

For our current example, the answers to be entered for each prompt include:

-   `analysis to perform`: 1
-   `name of construction`: QL
-   `corpus size`: `r sum(apple_word_freq$n)`
-   `Fisher-Yates`: no 
-   `tab-delimited input data`: \<qilai.tsv\>

------------------------------------------------------------------------

If everything works properly, you should get the output of `coll.analysis.r` as a tsv file in your working directory.


## Interpretations

The output from `coll.analysis.r` is a tab-delimited csv file (i.e., the data frame with all the statistics). A sample output file from the collexeme analysis of QILAI is available in the root directory `2025-10-XX XX-XX-XXXX.csv`.

- We load the results and check the top collexemes:

```{r purl=T}

## convert into CSV
collo_table<-read_tsv("2025-10-03 08-35-47.915105.csv")

## auto-print
collo_table %>%
  filter(RELATION =="attraction") %>%
  arrange(desc(LLR)) %>%
  head(50) %>%
  select(WORD, LLR, everything())
```

The output includes several useful **COLLSTRENGTH** measures, specifying the association between the collexemes and the slot of the construction (`V + 起來`).

- LLR/PMI
- Log Odds Ratio
- Delta P
- Kullback-Leibler Divergence (KLD)


------------------------------------------------------------------------

With the collexeme analysis statistics, we can therefore explore the top N collexemes according to specific association metrics.

Here we look at the top 10 collexemes according to four different distributional metrics:

1.  `QL`: the raw joint frequency of the word and construction.
2.  `DELTAPC2W`: the delta P of the construction to the word
3.  `DELTAPW2C`: the delta P of the word to the construction
4.  `LLR`: the log-transformed *p*-value based on Fisher exact test

```{r out.height = "100%", purl=T}
## from wide to long
collo_table %>%
  filter(RELATION == "attraction") %>%
  filter(QL >=5) %>%
  select(WORD, QL, 
         DELTAPC2W, 
         DELTAPW2C,
         LLR) %>%
  pivot_longer(cols=c("QL", 
                      "DELTAPC2W", 
                      "DELTAPW2C",
                      "LLR"),
               names_to = "METRIC",
               values_to = "STRENGTH") %>%
  mutate(METRIC = factor(METRIC, 
                         levels = c("QL", 
                                   "DELTAPC2W",
                                   "DELTAPW2C",
                                   "LLR"))) %>%
  group_by(METRIC) %>%
  top_n(10, STRENGTH) %>%
  ungroup %>%
  arrange(METRIC, desc(STRENGTH)) -> coll_table_long

## plot
coll_table_long %>%
    mutate(WORD = reorder_within(WORD, within= METRIC, by=STRENGTH)) %>%
    ggplot(aes(WORD, STRENGTH, fill=METRIC)) +
    geom_col(show.legend = F) +
    scale_fill_brewer(palette = "Dark2") +
    coord_flip() +
    facet_wrap(~METRIC,scales = "free") +
    tidytext::scale_x_reordered() + 
    labs(x = "Collexemes",
         y = "Strength",
         title = "Collexemes Ranked by Different Metrics")
```

The bar plots above show the top 10 collexemes based on four different metrics: `QL`, `DELTAPC2W`, `DELTAPW2C`, and `LLR`.

::: alert
Please refer to the assigned readings on how to compute the **collostrengths**. Also, in @stefanowitsch2003, please pay special attention to the parts where Stefanowitsch and Gries are arguing for the advantages of the collostrengths based on the Fisher Exact tests over the traditional raw frequency counts.

Specifically, **delta P** is a very unique association measure. It has received increasing attention in psycholinguistic studies. Please see @ellis2006 and @gries2013 for more comprehensive discussions on the issues of association's directionality. I need everyone to have a full understanding of how **delta p** is computed and how we can interpret this association metric.
:::


::: exercise
If we look at the top 10 collexemes ranked by the collostrength, we would see a few puzzling collexemes, such as `一`, `了`, `不`. Please identify these puzzling construction tokens as concordance lines (using `quanteda::kwic()`)and discuss their issues and potential solutions.
:::

```{r eval=T, echo=F}
apple_tokens<-as.tokens(str_split(apple_df$text_tag,"\\s+"))
kwic(apple_tokens, pattern = phrase("了 起來"))
kwic(apple_tokens, pattern = phrase("一 起來"))
kwic(apple_tokens, pattern = phrase("不 起來"))
```

## Distinctive Collexemes

We can also use Stefan's Stefan's `coll.analysis.r` for distinctive collexeme analysis.

Here we use our data from the following analysis as an illustration:

> Huang, P. W., & Chen, A. C. H. (2022). Degree adverbs in spoken Mandarin: A behavioral profile corpus‑based approach to language alternatives. *Concentric: Studies in Linguistics*, 48(2), 285-322.

In this study, we look at the differences among the four degree adverbs: `很`, `蠻/滿`, `超`, `太`. 

As before, we use the function `coll.analysis()` to start the interactive script. For our current example, the answers to be entered for each prompt include:

-   `analysis to perform`: 2 (= Distinctive Collexeme Analysis)
-   `number of distinctive cateogries`: 2 (3+ alternatives)
-   `tab-delimited input data`: \<input-distcollexeme.tsv\>

:::info

The expected input for Distinctive Collexeme Analysis is a data frame, which includes the target collexeme and the constructional element of all constructional tokens from the corpus. In our case, the constructional elements would be the degree adverbs, and our focused collexemes would be their cooccuring modifyees. 

We get our data frome concordance lines:

```{r echo=F, out.width="100%"}
knitr::include_graphics("demo_data/degree_adv_annotation_example.png")
```

And for Stefan's script, we only need the two target columns: collexemes and constructional elements.

```{r echo=F}
read_tsv(file = "demo_data/input-distcollexeme.tsv") %>%
  group_by(CONSTRUCTION) %>%
  sample_n(10) %>%
  ungroup
```
:::

------------------------------------------------------------------------

Then the program will automatically generate the output report as a csv file in your root directory. An example is available in the root directory.

```{r}
### Distinctive Collexeme Analysis: Results Exploration
dist_results <- read_tsv("2025-10-02 04-10-56.334203.csv")

dist_results %>%
  group_by(LARGESTPREF) %>%
  top_n(10, SUMABSDEV) %>%
  select(COLLOCATE, SUMABSDEV, LARGESTPREF) %>%
  ungroup %>%
  arrange(LARGESTPREF) %>%
  mutate(COLLOCATE = reorder_within(COLLOCATE, within= LARGESTPREF, by=SUMABSDEV)) %>%
  ggplot(aes(COLLOCATE, SUMABSDEV, fill=SUMABSDEV)) +
    geom_col(show.legend = F) +
    scale_fill_distiller(palette="YlOrRd", direction=1)+
    coord_flip() +
    facet_wrap(~LARGESTPREF,scales = "free") +
    tidytext::scale_x_reordered() + 
    labs(x = "COLLOCATE",
         y = "STRENGTH(SUMABSDEV)",
         title = "DISTINCTIVE COLLEXEMES")

```
